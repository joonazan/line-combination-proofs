\documentclass{article}

\usepackage[numbers]{natbib}
\usepackage[a4paper]{geometry}
\usepackage[most]{tcolorbox}

\title{Towards Fast and Correct Round Elimination}
\author{Joonatan Saarhelo}

\begin{document}

\maketitle

Only sometimes incorrect proofs get published. On the other hand, most programs are wrong. The list of software that afl-fuzz\cite{AFL} found bugs in illustrates this pretty well. Despite that, software is used to prove mathematical results. In my master's thesis I want to produce a convincingly correct implementation of one such algorithm, Round Elimination.

\section{Round Elimination}

Brandt et al.\ introduced round elimination in 2019\ \cite{speedup}. Dennis Olivetti wrote an implementation of it called Round Eliminator\ \cite{RE}. Round Elimination has been used to prove bounds on time complexity for various problems in the LOCAL model\ \cite{tc1, tc2, tc3}.

In Round Eliminator, problems are represented as \emph{lines}. Lines are a kind of shorthand notation that compresses multiple multisets into one line. Each line is a multiset of sets and represents all the multisets obtained by choosing one color from each set.\ \cite{RE}

The new active side consists of all lines that only contain configurations present in the old passive side, excluding lines that are subsets of other lines. The new passive side consists of all configurations made of new active sides' symbols that contain a configuration from the old active side.\ \cite{DA2020}

Written as a computer program, the above definition is a very concise and slow implementation of round elimination. To prove the correctness of a round elimination algorithm it suffices to prove that its output contains the same configurations as the reference implementation's output.

\section{Proving Correctness}

I'll probably use Coq, as it is very reliable and performs well. Coq programs can be extracted to OCaml, which can be decently performant. Round eliminator is written in Rust, however, and beating that with OCaml can be difficult.

One could compare the output of the Rust and OCaml programs, which is decent for verifying results found by the Rust version but not very helpful for finding bugs in the Rust version while developing it.

Proving Rust

There are a number of fully automatic verification tools for Rust but most of them are not applicable because they only prove the absence of runtime errors. Prusti allows annotating functions with their behaviour as well. The downside is that it may not always find a proof. Whether it is powerful enough to be convenient in this project remains to be seen.

Electrolysis is a project from 2016 that converts Rust to Lean 2 code with the same behaviour. The code can then be proven correct in the proof assistant.

It covers a remarkable amount of the Rust programming language (see http://kha.github.io/electrolysis/) even though it is just one person's master's thesis. Doing something similar today should be easier, as the Rust compiler has been changed to make developing tools easier.

The conversion makes impure functions pure by changing functions that take a mutable reference to functions that take an argument and return a modified version. The performance of the code changes but its output doesn't.

Not proving Rust

Round Eliminator could be modified so that it produces the result along with a reasoning chain of why the result is correct. The reasoning could then be checked by a separate program written in a proof assistant. This works well if the reasoning is concise enough that producing it doesn't become the bottleneck. This requires further research.

Proof strategy

Writing maintainable proofs in Coq means writing tactics that automatically do a lot of the busywork required to write proofs about the domain's data structures. Often tactics convert data structures to a canonical form, which is nicer to operate on. There are also external programs that write proofs for some solved problems, for example omega for solving linear equations.

The most important data structure in this proof will be the one representing a problem. Its multisets are not suitable for a performant program but maybe they aren't helpful for proofs either. I will have to compare a straightforward encoding with the one that Round Eliminator uses and try to find one that is easy to reason about.

Coq-hammer and Tactician are tools which try to automatically write proofs by selecting tactics based on heuristics. Trying them wouldn't hurt but they may not work well in this domain.

Making RE faster

At a glance I've noticed that Round Eliminator duplicates some metadata that could be stored higher up. In general, the memory layout could be improved.

I hope I'll come up with some algorithmic improvements as well while working on the proof.

\bibliographystyle{plainnat}
\bibliography{plan}

\end{document}
